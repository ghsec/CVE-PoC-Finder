package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"net/http"
	"os"
)

type ExploitResponse struct {
	Description string              `json:"description"`
	Entries     map[string][]string `json:"entries"`
}

func main() {
	// Define a command-line flag for the CVE keyword
	cveFlag := flag.String("cve", "", "CVE keyword to search for")

	// Set a custom usage message
	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage: %s -cve CVE-XXXX-XXXX\n", os.Args[0])
		fmt.Fprintln(os.Stderr, "Options:")
		flag.PrintDefaults()
	}

	// Parse the command-line flags
	flag.Parse()

	// Check if the -cve flag is provided
	if *cveFlag == "" {
		flag.Usage()
		return
	}

	// URL of the API with the provided CVE keyword
	apiURL := fmt.Sprintf("https://api.exploit.observer/?keyword=%s", *cveFlag)

	// Make a GET request to the API
	response, err := http.Get(apiURL)
	if err != nil {
		fmt.Println("Error making GET request:", err)
		return
	}
	defer response.Body.Close()

	// Decode the JSON response
	var exploitResponse ExploitResponse
	decoder := json.NewDecoder(response.Body)
	err = decoder.Decode(&exploitResponse)
	if err != nil {
		fmt.Println("Error decoding JSON response:", err)
		return
	}

	// Print specific information with formatting
	fmt.Println("Description:", exploitResponse.Description)
	fmt.Println("Entries:")
	for fileType, urls := range exploitResponse.Entries {
		fmt.Printf("- %s:\n", fileType)
		for _, url := range urls {
			fmt.Printf("  - %s\n", url)
		}
	}
}
